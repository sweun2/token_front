{"ast":null,"code":"import { argsert } from './argsert.js';\nimport { assertNotStrictEqual } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {};\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n\n    const _s = positionalCount - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n\n    if (missing) {\n      const customMsgs = [];\n\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n    let checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n\n    const newAliases = yargs.parsed.newAliases;\n\n    for (const a of [key, ...aliases[key]]) {\n      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  };\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      val = argv[val];\n    }\n\n    return val;\n  }\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  const frozens = [];\n\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      checks,\n      conflicting\n    });\n  };\n\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      checks,\n      conflicting\n    } = frozen);\n  };\n\n  return self;\n}","map":{"version":3,"names":["argsert","assertNotStrictEqual","levenshtein","distance","objFilter","specialKeys","validation","yargs","usage","y18n","shim","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","positionalCount","_","length","_s","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","key","Object","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","checkPositionals","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","_getParseContext","isValidAndSomeAliasIsNotNew","slice","unknownCommands","newAliases","parsed","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","Error","implied","implies","arguments","k","Array","isArray","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","filter","c","frozens","freeze","unfreeze","frozen","pop"],"sources":["/home/sweun2/Desktop/test/sol/front/node_modules/yargs/build/lib/validation.js"],"sourcesContent":["import { argsert } from './argsert.js';\nimport { assertNotStrictEqual, } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||\n                !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global,\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = distance(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, checks, conflicting } = frozen);\n    };\n    return self;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
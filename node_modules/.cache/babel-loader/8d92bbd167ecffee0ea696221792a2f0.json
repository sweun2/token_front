{"ast":null,"code":"'use strict';\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n  constructor(opts) {\n    var _a;\n\n    this.width = opts.width;\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    this.rows = [];\n  }\n\n  span() {\n    const cols = this.div(...arguments);\n    cols.span = true;\n  }\n\n  resetOutput() {\n    this.rows = [];\n  }\n\n  div() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n      this.div('');\n    }\n\n    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n      return this.applyLayoutDSL(args[0]);\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.colFromString(arg);\n      }\n\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n\n  shouldApplyLayoutDSL() {\n    return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\\t\\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n\n  applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0; // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n\n    rows.forEach(columns => {\n      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n      }\n    }); // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this.measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n\n  colFromString(text) {\n    return {\n      text,\n      padding: this.measurePadding(text)\n    };\n  }\n\n  measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = mixin.stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    }); // don't display any lines with the\n    // hidden flag set.\n\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n\n  rowToString(row, lines) {\n    this.rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n\n        const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n\n        let ts = col; // temporary string used during alignment/padding.\n\n        if (wrapWidth > mixin.stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n        } // align the string within its column.\n\n\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          const fn = align[row[c].align];\n          ts = fn(ts, wrapWidth);\n\n          if (mixin.stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n          }\n        } // apply border and padding to string.\n\n\n        const padding = row[c].padding || [0, 0, 0, 0];\n\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        } // if prior row is span, try to render the\n        // current row on the prior line.\n\n\n        if (r === 0 && lines.length > 0) {\n          str = this.renderInline(str, lines[lines.length - 1]);\n        }\n      }); // remove trailing whitespace.\n\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n    return lines;\n  } // if the full 'source' can render in\n  // the target line, do so.\n\n\n  renderInline(source, previousLine) {\n    const match = source.match(/^ */);\n    const leadingWhitespace = match ? match[0].length : 0;\n    const target = previousLine.text;\n    const targetTextWidth = mixin.stringWidth(target.trimRight());\n\n    if (!previousLine.span) {\n      return source;\n    } // if we're not applying wrapping logic,\n    // just always append to the span.\n\n\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n\n  rasterize(row) {\n    const rrows = [];\n    const widths = this.columnWidths(row);\n    let wrapped; // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n\n      if (this.wrap) {\n        wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n      } // add top and bottom padding.\n\n\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n\n        const rrow = rrows[r];\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n\n  negatePadding(col) {\n    let wrapWidth = col.width || 0;\n\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n\n    return wrapWidth;\n  }\n\n  columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || mixin.stringWidth(col.text);\n      });\n    }\n\n    let unset = row.length;\n    let remainingWidth = this.width; // column widths can be set in config.\n\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n\n      return undefined;\n    }); // any unset widths should be calculated.\n\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n\n      return w;\n    });\n  }\n\n}\n\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n\n    return '  ';\n  }\n\n  return '';\n} // calculates the minimum width of\n// a column, based on padding preferences.\n\n\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n\n  if (col.border) {\n    return minWidth + 4;\n  }\n\n  return minWidth;\n}\n\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n\n  return 80;\n}\n\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n\n  return str;\n}\n\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  /* istanbul ignore next */\n\n  if (strWidth >= width) {\n    return str;\n  }\n\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\n\nlet mixin;\nexport function cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n  });\n}","map":{"version":3,"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","_a","width","wrap","rows","span","cols","div","resetOutput","args","length","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","undefined","noAnsi","stripAnsi","match","toString","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin"],"sources":["/home/sweun2/Desktop/test/sol/front/node_modules/cliui/build/lib/index.js"],"sourcesContent":["'use strict';\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */\n    if (strWidth >= width) {\n        return str;\n    }\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}